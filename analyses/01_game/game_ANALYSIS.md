###CS 308 Project 1 Write-up

##Journal

This project was started on Saturday, August 29th, when a design document was submitted describing the basic layout of this game. This design proved mostly accurate, albeit with a few slight changes due to coding constraints. Actual coding began on Monday, with two or three hours spent each day from Monday to Wednesday. Then, on Thursday, I coded for 12 hours straight, taking the project from a basic design structure that could not be run to a fully-fledged and working game. Most of the first six to eight hours were spent developing the design, e.g. what was the core game loop, how do I handle going between levels, how do I manage all of the game objects on screen, what are the physics, etc. Once I had that down, I started work on a preliminary debug phase that actually displayed two unmoving game objects that collided with each other, the player and a terrain block. At that point, I began to realize that the model was quite adequate, and the internal physics functioned more or less perfectly, but my display system was simply inadequate. I spent the first portion of the twelve-hour chunk redesigning my view system for the game, inverting the y-display and creating a class which held my sprite data and reversed the coordinates for display. Then, I realized that I sometimes needed to attach multiple sprites to one game object, such as a direction indicator and likely in the future a health indicator, so I set the object to have an array of display objects, each of which had sprite info and a coordinate offset from the basic draw location, and in addition reversed the display coordinates. This worked well but I ran into a huge series of problems in displaying a generic node, as when I passed in a rectangle that lost some of its parameters, motion no longer worked correctly. In the end, I dodged the problem by requiring the engine to display rectangles as opposed to generic nodes, something I would fix in the future if I were to further develop this game. At this point, the core engine was working and the display worked, and from there it was trivial to implement enemies, the ending door, and weapon objects, all of which I implemented over the course of roughly six hours in an implement-debug loop. Because I spent so much time developing and thinking about the core engine, it was very easy to add new features, as they just slid right into the existing schemata. The most difficult aspect of the project by far was handling the “view” segment of the model-view framework. The documentation on Node display for javafx is incredibly poor, and in addition, each node has several coordinate systems that are sometimes overridden by information from the child class. If someone else were to handle the display work, I could almost certainly have built an incredibly complex and varied game over the span of the twenty hours I worked. 
My committing habits for this project were terrible. It was no problem in this case, as I was the only developer involved in this project, and were anyone else to have worked on it, I would have committed at least twice a day or so. That being said, for this project I committed twice, once with a WIP that was semi-playable and once with a finished product. There were correctly annotated (as much as one commit covering 700 or 800 lines of code could be). The first commit, covering the WIP, was essentially the core structure of the game, covering the game loop itself, the level manager, the sprite manager, the drawing manager, the core game object, the player, and the terrain block. Display was not working correctly at that time, I believe, but the physics themselves were more or less accurate. As previously stated, this commit size was unreasonably large, but I was the only developer, so it did not matter. The second commit included the rest of the features, including the three robots, the weapon, the ending door, and the collision for these objects. This commit was also quite large, and I would have split it up into segments were I not also the reviewer of my commits. I had to do very little refactoring in the end, although there is a small amount that still could be done (moving the rectangle instantiation from the individual object constructors to the base sprite constructor, as every object has a rectangle denoting its location in space, moving a large amount of the constants to a settings file, moving the transitions handling to its own separate class). In general, I spent a lot of time in development thinking about how things should be structured, so most things ended up where they should be the first time I wrote them (drawing information aside). 
Overall, I massively underestimated the size of this project. My levels were so complicated that I needed a level manager to handle their spawning, I needed a huge amount of physics to handle all of the collision, I was attempting to display multiple sprites for a game object, so my view code got insanely complex for a tiny game, and in general I was too ambitious with what I needed to deliver. That being said, I did deliver virtually everything that I promised in the original design text, with the notable exception of a boss-type enemy and a third move for the player (which both would have been trivial additions to fit into the game’s current design). If I were to continue developing this project, I would first (after commenting up everything) implement health bars, then implement a boss character, and then refactor the attacking code pre-object spawn to have a general system in place for humanoid objects (maybe all game objects) that handled cooldowns for attacks and abilities, because that code was starting to get gnarly for each different attack. In general, though, my design was satisfactory. 

##Design Review

This code is consistent in its naming conventions, layout, and style. The commenting is terribly done, and would need to be extensively marked up before anyone else were to work on this project, but the code is also laid out in such a way and things are named in such a way that a user familiar with design would fairly easily be able to trace out the structure of the game. At the time of writing, there are only a couple workarounds that I can think of that would require substantial explanation with commenting, and they are mostly display-related (which I have already acknowledged still confuses me and is likely the weakest part of the program, other than its lack of start screen/end screen). The dependencies are fairly straightforward, although I did end up having to make some choices that seemed less than ideal. For one, my level manager was a separate class from my game loop, and so information that a simple game would have had access to, such as an instance of the sprite manager, was unavailable to the level manager by default. To get around this, I passed in an instance of the sprite manager at constructor time which was used by the level manager to add sprites to the sprite manager when they were created. If possible, I try to avoid things such as giving access like that to a class, but I could not think of a good way around it short of redesigning the entire code base and turning level manager and sprite manager into components that the game loop implemented (which would work well but work orthogonally to the current structure). In addition, the sprite manager needed access to the myNodes variable of the game loop in order to handle all of the display of sprites. This one I felt less bad about, as this is pretty much the intended use of the object manager, and there was no easy way around it. Finally, I passed in the sprite manager at construction time to some of the game objects, so they could add themselves to it, but they did not retain the manager as a variable, so they only had access at construction time. This is a tradeoff: if I were to simply add the sprite to the manager in the level spawner, then I don’t have to pass it in to the constructor, but I am also responsible for correctly choosing the correct list to add it to (I kept separate lists of weapons, terrain, and humanoids, because each type had different collision logic). All in all, I like the way that I did it, although it is slightly incongruous with my method of humanoids spawning weapons (since they don’t have access to the sprite manager anymore, they instead create and return the sprite to the manager, which then handles adding the sprite to the manager at that point). 
At this point, I will point to two specific portions of code, one of which I believe is designed well, and one of which I would restructure in hindsight. The first, which is done well, is the basic game loop. First, I tell the object manager (when I say sprite manager, I mean object manager, as spritemanager is poorly named) to update all objects. This function in the object manager then calls the generic object update function, which is overridden for each sprite by its subclass update method. These handle such things as how the sprite moves this frame, whether an attack was requested, and what the cooldowns on the object are (ability cooldowns, lifespan on weapon objects, etc). After this, the collision is handled for each object. There are four separate collisions: humanoid with terrain, weapon with humanoid, weapon with terrain, and player with door. Each of these triggers a different action: pushback from the terrain and inability to move in collision direction, damage from the weapon, despawning of the weapon, and a level end (if all enemies are dead), respectively. After this, any dead sprites have been added to a removal list, and these sprites all are removed together. This code is succinct, and incredibly easy to understand. Something which is incredibly complex (all of the different things that can happen when two game objects collide with each other) is segmented and split into separate sections, each of which use mostly similar logic that has been factored into a collision detector, differing only on the results once things have collided. This code is how any simple platformer should perform a basic frame loop. 
In contrast, my code on cooldowns is somewhat confusing and could stand from refactoring. When I press a key that corresponds to an ability, the sprite manager gets the player sprite and tells it an action is requested. This part is correctly done. However, each frame, when I handle movement and attacks, each cooldown is a separate variable, and it’s unclear how they all interact with each other and which cooldowns actually prevent movement (some ability cooldowns do this, on a case-by-case basis). In addition, all humanoids have cooldowns on their base attacks, so it seems prudent to implement a cooldown handler for all humanoids (or perhaps even all game objects if down the line we want weapon objects to do something on a frame-by-frame basis). However, once the cooldown section has been passed, the segment of the code that handles spawning a weapon is quite well done (an abstract method in the humanoid class that is overridden by derived classes to handle what kind of weapon they want to spawn, with what parameters). 
The design of my game, despite all of the organization it took, is fairly simple to explain (as it would be for any game written in a week). I borrowed the basic instantiation from the example game, as it calls an init function and then steps each frame. In the step function, as previously described, I use the sprite manager to update every sprite, and then to handle all collision, and then finally to remove all dead sprites (if the player has not collided with the end door). In init, and when the level-end condition is met, in the core loop, the level spawner receives a call to end the level, which sets transition state to true, despawns all objects, and then determines which pattern to use for the subsequent level. The patterns cycle modulus five, resulting in five increasingly difficult patterns of enemies and terrain. After the transition has been present long enough, a key or mouse input will end the transition state, starting the game logic again. There are four kinds of game object: the humanoid, the terrain, the weapon, and the door. The humanoid is all moving characters with health that attack (including both the player and all enemies). The terrain is an unmoving object that collides with all humanoids and weapons. The weapon is an object spawned by the humanoid that simply moves and applies damage when it collides with a humanoid (and despawns when it collides with terrain). Finally, the door only collides with the player object and triggers a level end once it does. Each subclass of humanoid has slightly different display and health info, and different movement and attack logic, but fundamentally all subclasses act very similar. All interaction between sprites is managed by the sprite manager, which also handles all drawing and de-drawing calls (in a specific drawSprites and removeSprites call). All drawing information is held in a class which holds draw data, and an offset from the base position. The base object class contains an array of these draw objects, and new ones are added as needed by subclasses to handle other things that need to be drawn (such as, eventually, health bars). 
To add a new level to the game, you would have to change the pattern-spawning apparatus. However, that would not be very difficult. In the level manager, you would change NUM_LEVELS to six, instead of five. Then, you would write a function like loadPatternOne-Five which you called when level modulo NUM_LEVEL was six (or seven, or whatever the previous count was + 1). In this pattern, you put all the spawning information about terrain and enemies. This fully handles the spawning of a new level. 
I have already spoken somewhat at length about the design I chose to use, but it is worth saying that I designed it the way I did with mainly an eye to modularity and ease of adding new features. The level manager and sprite manager handle all sprites in the types I could conceivably create for this game, full stop. Because of this, all that needs to change is implementing new subclasses or methods in my existing classes that allow my characters or weapons to do new things. However, the fundamental assumption is that my game code is split into two parts: core game code (managers, the game loop), and object code, which is what is being managed. Things that blur the line between these two parts would be difficult to implement in my system. 

##Code Masterpiece

I will highlight two game requirements here: win/lose conditions, and cheat code. The win/lose conditions are clear, in that the game loop stops if the player runs out of health, and the level ends if the player collides with the door. Both of these are done in the collision phase: if the player collides with a bullet and his health hits 0, then the loop stops. Alternatively, if the player collides with the door, the collision function returns true, and the game loop calls an endLevel routine. These are clearly defined within the code, so it is easy to see exactly how the player wins. 
There are, of course, alternate designs for this game. Since game design is based on paradigms, if someone were to use alternate paradigms, they would come out with a game that functioned mostly the same way, but consisted of an entirely different structure. I will quickly analyze two design choices here: First, the previously-design choice of passing the level manager to the constructor of subclasses to correctly handle their addition to the sprite manager automatically, and second, the creation of weapons in the subclasses of humanoids and their subsequent passing to the sprite manager to handle addition to the proper list. The first case I have already described, so I do not need to retread that ground. However, the second case I believe is a case of especially good design. In this case, I know that every time, I am making a weapon sprite, so I can add it to the weapons list without worrying about what its type is, even if it is a subclass (because all weapons are managed the same way in terms of collision). Therefore, I can call the general weapon spawn case, and the subclass will handle what exactly I am making, what size it is, etc. This allows for separation between the sprite manager and the sprite, while still properly keeping track of what needs to be kept track of. I will include the prudent code as follows:
In spritemanager:
if (a.getIsMakingWeapon()) {
					Weapon newWeapon = a.makeWeapon();
					addWeaponSprite(newWeapon);

In the humanoid superclass:
    public Weapon makeWeapon(){
//    	Does Java have polymorphism?
    	return null;
    }

In the samurai class:
	public Weapon makeWeapon () {
		Weapon newWeapon = null;
		if (myAttack == Slash.STAB) {
			newWeapon = new Weapon(getX(), getY(), STAB_WIDTH, STAB_HEIGHT, STAB_COLOR, this);
			newWeapon.initWeapon(true, STAB_DAMAGE, STAB_LIFESPAN, 0);
		}
		if (myAttack == Slash.DASH) {
			newWeapon = new Weapon(getX(), getY(), DASH_WIDTH, DASH_HEIGHT, DASH_COLOR, this);
			newWeapon.initWeapon(true,DASH_DAMAGE, DASH_LIFESPAN, 0);
			setIsInvincible(true);
			isUsingDash = true;
		}

		setIsMakingWeapon(false);
		myAttack = Slash.NO_MOVE;
		return newWeapon;
	}

In the RobotA class:
	public Weapon makeWeapon() {
		Weapon newWeapon = new Weapon(getX(), getY(), ROBOT_A_ATTACK_WIDTH, ROBOT_A_ATTACK_HEIGHT, ROBOT_A_ATTACK_COLOR, this);
		newWeapon.initWeapon(true, ROBOT_A_ATTACK_DAMAGE, ROBOT_A_ATTACK_LIFESPAN, 0);
		
		setIsMakingWeapon(false);
		myAttackTimeCounter = ROBOT_A_ATTACK_CD;
		return newWeapon;
	}

Finally, the weapon construction:
	public Weapon (double x, double y, double width, double height, Color color, Humanoid creator) {
		super(x, y, width, height);
		myCreator = creator;
		
		Rectangle myRect = new Rectangle(x , y + DEFAULT_WEAPON_HEIGHT, width, height);
		myRect.setFill(color);
		setRect(myRect);
		
		setX(x);
		setY(y + DEFAULT_WEAPON_HEIGHT);
	}
	
	public void initWeapon (boolean attached, int damage, int lifespan, double speed) {
		isAttached = attached;
		myDamage = damage;
		myLifeSpan = lifespan;
		Vx = speed;
		
		if (!isAttached) {
			setX(getX() + myCreator.getDir() * getRect().getWidth());
		}
	}

Each override gives the call the information it needs.

Finally, three bugs important to the project:
First, there is the problem that when weapons hit the edge of the screen, they technically do not collide with anything, so they do not despawn until their lifespan ends. This is obviously annoying as you can run into them when they should already be gone.
Second, collision at the edge of terrain is wonky. Sometimes you slide through the edges of blocks. I am not totally sure as to why this happens, but I believe it is because of the pushback functions that fix your position when you collide with a terrain block, and their lack of expected performance. 
Finally, if you stand on top of an enemy and use your abilities, they never appear because one frame after they spawn, they collide with the enemy and despawn. This is not a bug, per se, but it is confusing to the user. Ideally, some animation would play when a weapon hits, or at least there would be a health count visible to the user that would go down.
