#Analysis

##Project Journal

###Time Review

I spent a very, very large amount of time on this project. We first started meeting before the groups were technically formed, because we all knew each other through two or three central people, so we could start early. We had several design meetings at this stage, each one at least two or three hours. After the groups were officially formed, we met roughly every other day for one or two weeks, for a duration of somewhere between two and five hours. At this point we built a more or less completely functioning engine, but the team was not completely comfortable with the design, and extensively refactored and removed large parts, getting rid of a huge section of our functionality. I then took a long break from the Friday before Thanksgiving week to the end of Thanksgiving week, because I had an onsite interview and went to see relatives in California. When I returned, we started meeting every day to work on the code. We built an engine – again – and proceeded to re-implement most of what we had built before with mostly the same design patterns. At this point, the authoring environment was finally catching up. However, we still had several crunch periods that we needed to do in order to bind everything together successfully, and make sure features the engine had could actually be implemented (on an individual grade basis it shouldn’t really matter for the engine but at the same time none of us really felt comfortable leaving them out to dry if they didn’t implement all of the proper features). Our final code freeze night, we spent twenty consecutive hours coding, from 4 PM the previous day to 12PM the code freeze day. Overall, I spent significantly more than 100 hours on this project, and if I had to estimate would likely say 150 or so. I wrote 11,000 lines of code, but about 3,000 of that was a repository copy, so in actuality the number of new, content-ful lines I wrote was likely around 8,000. Most of my time was spent working on the engine, building new features. We had design patterns that were so strong that I rarely needed to refactor, so I could mostly just build features, run the code and do light debugging until they worked, and then add things to the documentation.

The biggest time sink in our project, by far, was the extensive and largely unnecessary game engine refactor we did in the midpoint of this project. Rather than doing research and figuring out whether the patterns we used made sense (I will explicate them in the Design Review), we simply for some reason assumed they were insufficient, and moved away from them. By the end of the project, however, we had re-implemented most of them, because upon doing research they were actually recommended practices. 

###Teamwork

For all of our design struggles and feelings of frustration, the team was the best team I have ever worked on. Our biggest key to success was simply the absurd amount of times that we met. I worked in the Link with at least 3 or 4 members and often 8 or 9 once every other day, early in the project, and daily by the end. Most of our design meetings occurred early, and occurred over and over until everyone’s fears and lack of understanding regarding patterns and structures was settled. Mostly the different sub-teams met separately – I met with the engine team (Brody, Nick, and me), and the authoring team met in a different group (Elsie, Michael, Arthur, Henry). The other people more or less functioned as floaters working on different miscellaneous parts of the game, like the game front-end or the XML, and in addition would go between the different groups doing work and describing design needs. In retrospect, I wish that we had communicated more with the Authoring team, because we finished our code much before they did, and if we had known more we could have worked on it earlier and gotten it farther ahead. However, within our own team, we met frankly an absurd amount of time (I would actually find it impossible to condone our meeting schedule as a class policy or recommendation, and think it is an unrealistic expectation to have of a group, but we were all willing to do it). 

Our plan for the project was to design each module as separately as possible. The engine team would build an engine that worked with game objects that were loaded and saved to XML. The authoring team would build an editor that worked with game objects that were loaded and saved to XML. That way, the authoring team had little to no needs from the engine, other than the type and necessary fields for the game objects (and for the game as a whole). This worked well in the sense that the groups could work separately, but backfired in the sense that we did not pay close attention to the inner workings of the authoring environment group and did not realize until later into the project that they were lagging slightly behind. Unfortunately, the limitations of a demo and of the rushed final grading process mean that the code written for the engine is 90% useless because no one will ever look at it or see it in action, and it is 100% useless if the authoring environment does not work. Therefore, we still had a crunch time at the end of the project were everyone scrambled to finish the authoring environment. At the end of the day, our specifications were mostly right, although we dropped the platformer aspect of our engine. Our design made it actually relatively easy (all we would have had to do was implement a Gravity attribute and a scrolling screen) but we wanted to make sure we could really nail the top-down genres instead of spreading ourselves too thin. 

###Features

The main way that I managed the code I was writing was through branches. I have been using Git since the beginning of the summer, and even now pull requests still feel strange to me and I only tend to do them when I am required to for assignments. Instead, I would split from master into my own branch, and write code and submit commits in the branch. When I had completed a feature, or the rest of the team strongly desired the code that I had written, I would either ask someone to merge my branch in (this is somewhat like a pull request) or simply merge it into master myself. Near the end of the project, everyone’s last several commits were in master, because everyone was pushing essential bugfixes and features that everyone else needed to be able to test the code. In addition, we were pushing changes to the code that saved object and game data, meaning that every push would break the existing xml files (an unfortunate side effect of using Xstream, and one that we likely would have had to solve by writing our own serialization functions). As a result, everyone needed the new code to know if they had to rebuild their game data. 

I largely took responsibility for the game engine. I created the core design pattern (all objects are treated as the same thing by the game engine, and have dynamically assignable attributes that make up its actual functionality. These objects communicate with each other via events passed through collisions, and communicate non-collision-based events through events passed into the event manager). I built the score system, the attribute system, the event system, most of the code for the “universe,” which is our term for all of the objects and settings of a game as a collection, the update system, the spawning system, and the game manager. In addition, I took responsibility for a scripting component that would be attached to objects and allow the user to dynamically give them event and attribute based functionality. However, this was not added due to time constraints (and concerns about how to implement this on the front-end). 

For example, take the spawning system. Since I had already worked out the attribute and event paradigms, it was a relatively easy task for me. I first decided that I should integrate with those systems. Therefore, I would load in data from xml, create objects based on that data, give them the attributes that the data said they required, and then pass this object in an event to the event manager, which would handle adding it to the systems which needed it (like the spawnyard, the view, etc) in an object creation event. The biggest challenge I had in doing this was figuring out where I would get the data for the objects, and how to manage a system that could handle spawning both for top-down shooting and arcade games and for tower defense games (which had waves). Eventually I solved this by treating every other type of game as a one-wave tower defense game where all the enemies spawn at once. I was able to do this mostly by myself, with some interfacing with our XML man, Jiawei, to discuss the object data format.
	
###Conclusions

I am running out of space here, so I will be brief. Going into this, I underestimated greatly how much time this would take. Building the engine actually was significantly easier than I thought, but frankly I work relatively quickly, and I was in a group of ten people, so I often had to wait for other people to implement things I needed, and once we finished the engine we built it again from scratch and then had to assist in the development of the authoring environment. I felt like I took on a good amount of responsibility for this project. Brody definitely spent the most time, and organized our meeting, and wrote the largest chunk of the code, but I would say I coded the 2nd or 3rd most after him. Honestly I feel like in large part my work for this project was very good, and the biggest thing I could do better going forward is to make sure all teams on the project are on the same page and are up to speed on their code – maybe we should have set hard deadlines for ourselves and on a team-by-team basis.

##Design Review

###Status

Our project is mostly consistent in its formatting, layout, naming conventions, and style. The biggest split in difference is between the code in our authoring environment and the code in our game. Naming conventions are still mostly the same across the whole project, but structure is different in the environment, in the sense that fewer interfaces are used. Across the game, our code is very easy to read, and all of our interfaces are commented so that any public function call has documentation attached. Our model is also very well separated from our view – we use the mvc framework so that our game objects know nothing about how they are displayed other than a file path to the image. These objects are mediated by the universe and engine before their relevant data is passed to the view section of the game, which instantiates javafx objects and observes our backend objects. This way, we can design features without caring at all about how they will look, and the front-end can display things without having to worry about that information being accessed by the model. In the authoring environment, this split is slightly less clear, but this makes sense because there are much fewer actual back-end objects in the environment, and much of the environment is essentially a large handler of javafx code and cases for displaying data in intuitive ways (which depending on the data could mean any number of different and obscure javafx structures which work well in this specific case). In particular, I would say that our core engine code is very easy to understand. We simply go feature by feature, and tell the feature to update itself. The feature then will update each of its components or members, and so on. This cascades downward and is trivially easy to follow from the top level, even if you have never seen this code before.

I will now examine three classes written by my group and assess their strengths and weaknesses. 

* ObjectView
This class was written as part of the view package. It represents the view for a single object, and is given the filepath for the image corresponding to the object along with a bounding box containing coordinates, size, and rotation/direction of the object. It uses these components to construct an image, and then observes the bounding box so that whenever it changes, the view updates as well. What I like about this is that it is self-contained, doesn’t know too much about the object, and never needs to communicate backwards to the object in the back-end. As a result, the object itself doesn’t have to care at all about the ObjectView, and the only indication it has at all that it’s being displayed comes from the fact that it has an observable bounding box and the fact that it has a filepath to an image. I don’t totally understand why the object is displayed in a stackpane, because it’s the only thing in the stackpane and what differentiates a stackpane is its display order, but it seems to be working so I don’t see too much issue with it. The only thing I would comment on is the inability of the objectview to change its imagepath if the object’s filepath changes or it needs to display a different sprite. We could handle that with a new object creation, but if we are sure we want the same object to have a different image, this class would not handle that need well.

* SpawnYard
This class was written as part of the universe package. It handles the addition of objects to the managed sets of gameobjects and to the view (although the actual object instantiation is done in a variety of places, the object only starts to be tracked when the spawnyard adds it to the universe, meaning the object essentially doesn’t exist until this point). It is clean, well-structured, and makes good use of interfaces. It listens for events, using the event system, and when it hears one, attempts to call it an ObjectSpawnEvent. If it actually is one, then it adds the object to the spawning list, and then when the spawnyard is updated (on the frame count) it adds all of the objects in its spawning list to the universe and to the view. By receiving the objects whenever but only actually adding them on the frame, the behavior of the game is standardized such that objects are only created and destroyed on frame updates, regularizing what the user sees and making it easier to track the order in which things happen. I would say that I think it is strange that the SpawnYard itself is responsible for adding objects to the view. I believe that the universe should probably be responsible for this when its addToGameObjects() function is called, because the SpawnYard shouldn’t even have to know that a view exists. Other than the mvc separation issue, though, this is a good class.

* IconPane
This class was written as part of the editor’s icon package. It handles the display of all of the data in a given directory as a pane of thumbnails in the editor. It works fairly well, makes good use of interfaces, and uses some complicated design patterns (including the passing of a function into its showDirectoryContents() functions that converts the files in a given directory to a certain type. However, there are some things that could be done better. First, there are two functions with very similar names that respectively return void and a map, showDirectoryContents() and showDirectoryContentsMap(). These both take a directory and a function that determines how to convert the directory into a list of strings, which is an interesting idea. However, the second function doesn’t use this passed in function at all, and merely duplicates the code that would have been passed into it from the DataLibrary. In addition, some documentation here would have been really useful. The function says it takes an object of an interface, but the DataLibrary call to the function passes in a function pointer to a function which converts the directory to a collection of strings. It took me a substantial amount of time to understand what is happening here, and I worked on this project, so I imagine it would take a new developer even longer. 

###Design

Our design for this project was very strong, overall. We, as I mentioned before, split the project into two parts, the authoring environment and the game engine/view. I did not work on the authoring environment, so I understand it less well, but essentially it consists of a large amount of buttons and panes that allow you to create and select attributes and settings of objects and save them. You can then view the directories of objects you have saved and drag them into the game map or the spawning list. This is all done through ObjectData, which is a shell containing data for an actual game object. As such, there is little hierarchy in the editor, and most of the code is just for a wide variety of options and tools you have in building single objects or maps. 
What I understand much more fully is the game engine and view. We sought and mostly succeeded in this project to have complete dependency inversion. As a result, almost every class has an interface or several interfaces associated with it describing a specific functionality of the object, and the objects are only referred to by their interfaces. As a result, it is completely safe to pass any object anywhere, as long as it is properly being treated as a specific interface with limited functionality. For example, the game universe containing all of the objects, the spawnyard, and the graveyard is regularly passed into our objects and score checkers and graveyard etc. in order to do updates and modify state. However, because it is passed as a controlled interface (IGameUniverse at very least, and usually a more specific interface like IObjectAdder or IObjectRemover) only a small amount of the functions it possesses are available, and the actual implementation of these functions is unknown and the separate parts don’t really care at all anyway. 

Another key feature of our design is the Composite and Event design patterns. Objects are all treated as GameObjects, with unified functionality and features by the game universe as it updates and iterates, spawns and despawns (there are a few small exceptions when towers are created, but the general interface is used 95% of the time). As a result, we can treat every object as if it is the same thing. Of course, different objects still need to have different features. However, we can dynamically attach and detach these features from the object. This is done using a system of “attributes” which describe a specific functionality that an object has. An object, for example, may be able to move, or may be able to lose health, or may give the player points when it dies, or money. These functionalities are moved into objects that handle them specifically, and then are added to a map that the object possesses describing the attributes it has. The name of the attribute (from a resource file) is mapped to the attribute, so when a specific attribute is needed, the call is made from the map. The object itself, however, does not care what attributes it has, and just tells each of its attributes to update. You may at this point be wondering, if the object does not know what attributes it has, and does not have any instances of other objects, how the objects communicate with each other. This is done in two ways. The first is through collision, which are managed by the game engine. The game engine checks to see if objects are colliding, and then if so, does a collision on them. This consists of getting the events for each object that it is supposed to perform on collision with another object of a certain type (done with an enum that could be in a resource file, and only used as a designation – not coded into the game). For the other object’s type, all of the events that the object says it is supposed to send are then sent, and act accordingly. An object, for example, may perform a health change event on another object if that object is an enemy. In this case, the collision event will then run itself on this object. These events are not passed into the event manager, and are handled specifically and solely through the collision manager. The reasoning behind this is that collisions are so frequent that it would slow the game down if every collision event was sent to every object. However, near the end of our project, we began to run into some design limitations here and were in the process of transferring these events into the event manager as well, reasoning that even with hundreds of these per frame the game would still almost certainly be fast enough on a modern machine. 
The other events are handled differently. When event is not based on a collision, but occurs as a result of something else (say, an object dying or spawning), it is instead simply just passed into the event manager. This event manager then sends the event to every object or structure registered to listen to events. The object then gets the event, checks to see if it cares about this specific event (through a try-catch type casting which interestingly I discovered is an industry-accepted practice) and if so processes the event based on the type it has successfully been cast to. This means that even if there 200 types of events, one event manager can handle them all, and the separate objects only have to implement functionality as needed for the events that they care about. 
As a sidenote, the on-the-fly creation of attributes allows our project to utilize a variety of design patterns relatively easily. For example, we can have a movement attribute that simply tells the object have a certain velocity based on its move function. Then, subclasses can implement this move function in different ways, resulting in a clean implementation of the Strategy design pattern, where the specific movement algorithm is swapped out as needed, and indeed the ability to move itself is added or dropped as needed as an attribute that gets updated like anything else. 

To represent a game, all that is needed is one huge xml file. The game xml file then contains a matryoshka-doll style pattern of xml objects which hold xml objects on downwards to a specific game object. The game holds a collection of levels and a global settings object. These level objects then hold data for the spawner, for the tower list, for the existing game objects, a game map data object, and a level settings object, which holds information specific to the level, such as starting gold, the win conditions for the level, etc. This continues to propagate downwards. This game data xml, however, is all you need, and when you load this into the game manager, it uses it to create a game object and then loads levels from there. The code needed to do this loading is in the GameManager, and on a level-by-level basis is the GameUniverse and the Spawner. 

I will now discuss two features in detail that I did not build.

* Win-Loss Conditions
I actually built these myself in the first iteration of our engine, but when we built again from scratch, someone else handled them. The win conditions make extensive use of our event pattern, and this allows them to function almost completely independently of everything else – ideal for a large project where dependencies exponentially complicate design and testing. Essentially, the win condition manager holds a win condition and a loss condition. The conditions are abstractly defined, and there is no real split between a win condition and a loss condition, only by the enum type that it is given. These conditions are held by the manager. The condition manager hears events, and passes them into the conditions, which then decide if they are relevant events or not. If they are, the condition gets marked as true and the condition manager broadcasts a level change event. This is a strong design, in that it is only tied to the rest of the game by its instantiation in the universe and by its addition to the list of event listeners, so it has few dependencies and absolutely no things are dependent on it existing at all. There is a potential weakness in the sense that it only stores one type of each condition, but that is relatively easily modifiable.

* Tower Shop
This design is slightly more convoluted, in my opinion. Tower placing and the tower shop is handled in the view. It makes sense to have a view which has a tower shop as a pane that can be seen and interacted with, but the actual placing of a tower, and the cost calculations themselves should probably exist outside the view package. Because of its all-in-one implementation, it is also somewhat difficult to say that this feature’s classes are closed. If a new part of the feature is desired, it may be difficult to move it into a new class and simply instantiate that class. This violates, in my opinion, model-view separation and probably would end up being refactored if we wanted to substantially expand the concept of tower buying and placing. 
 
###Alternate Designs

Our design expanded incredibly well over the course of development. The original, core paradigm that I suggested – event-based interactions between undifferentiated objects with compositionally defined features – exists almost exactly now as it did by describing. We did simplify the attribute system, as it originally consisted of a tree of attributes, and we changed the name from “component” to “attribute,” but other than that the broad engine design that we came up with bore us all the way through the project. 
The original API also held up well. As the design structure we used continued and continued to work, we were basically able to plug everything into this central system and found the system functioned quite well. We ran into slight problems with our conception of events, as we originally believed that events were between two objects, and there weren’t always two game objects that it made sense to describe an event as between, but after expanding the event framework to generally just take one object and then maybe another if it had a specific type, it continued to function well.

One design struggle we had was trying to decide where the specificity for functionality of specific features should go – should events know which attributes they interact with, or should attributes know which events that care about? We started with the latter, and then moved to the former. Then, as we expanded away from purely collision events, we found that having a general category of events that were “dumb” and were handled by their objects in terms of functionality ended up being useful. Therefore, we had two event categories – one that was just for collisions, and one that was for all other kinds of events. At the end, we considered merging these, but thought the system was too fragile to modify with the short window of time (less than 12 hours) we had left. I still tend to think that a dumb event that is being cast and handled by the attributes makes more sense, as it runs more with the conception of an event as something that happens generally, as opposed to specifically something that happens between two game objects. 

I have already discussed the strengths of this design in detail, but I will again reiterate shortly. The largest strength of this design is that it is completely modular and allows the general systems (the engine, the event manager, the object) to stay lightweight and simple. All information is passed generally and all objects are treated the same way during gameplay by the engine. The actual content-ful section of the game is all handled through events and attributes, which can exist independently and rarely need to interact with each other directly, making the design closed in general (unless one wants to have an attribute interact with a bunch of new events). The secondary strength is that we are not constricted in any way by functionality we want an object to have in terms of hierarchy – all objects work the same way so we don’t have to worry about making sure two children of different superclasses both have the same functionality we can rely on. 

The largest weakness of this design is its difficulty in making complex games and interaction patterns. This can to some degree be overcome by ingenuity with existing structures, but it is still relatively difficult. For example, in Pac-Man, in order to implement the feature where eating a large dot will make ghosts vulnerable, we would have to define a new event, figure out how to make a pellet broadcast that event when it dies (but have no other objects broadcast it upon death), have the ghost hear that event, add a health attribute, remove a damage event, and add a timer to have this state expire eventually. In contrast, with a hierarchical system we could just replace the ghost with a different object that had all of these features. This, of course, would be terrible for a general game engine, because you have to actually write code whenever you want a new object, but works much better for a single game with complex features. Our engine, simply put, would massively struggle on a single game with complex features, because that was not our design objective.

One way we could actually get around this problem is through scripting. If an object were to have a set of groovy scripts, and pass the event into each script, the script could dynamically determine whether it cared about the event and what the object should do in response, without having to modify any of our existing java code. A script on the pellet could hear its own ObjectDespawnEvent and in response broadcast a GhostChangeEvent, and a script on the ghost could hear the GhostChangeEvent and tell the ghost what attributes it needed to change. However, this change would have been very difficult to debug, and adds volatility to the project (do you really want a designer to be writing groovy code?) We could get around this problem by having a visual scripting language that created groovy code, but we simply didn’t have enough time to do that (I also am unsure how to write that javafx code and I don’t think our authoring environment team would have been able to handle it easily). As such, we stuck with our existing system.

##Code Masterpiece

My masterpiece is the event manager, along with one structure that listens to it (the score system). I actually believe so strongly in the design that is currently in our repository (with my masterpiece header at the top) that I don’t believe this needs refactoring, and represents an ideal design choice in terms of object interaction. Essentially, every object gets on its update call an event poster, to which it can send an event if it so desires. The event manager, when it gets these events (it implements eventPoster) sends them to all of the objects which are registered to listen for them (the manager also implement EventManager which allows calls to register an object with the manager). The objects then receive every event broadcast by the event manager. To decide which events they actually need to respond to, they use type casting. This on the surface sounds like a bad decision, and gave our group some headaches when first described (it has been beaten into our heads that type-checking is a bad thing) but in this specific case I could not find a way around it, and decided to do some research. What I found was that type checking through casting, in the specific situation where you can guarantee that an object of an interface type will only match a class cast if it is that specific event type, is an exception to this rule, and is not only not frowned upon but is regularly used in the industry to handle events. The alternative, of course, is to have separate event managers for each type of event, which becomes exponentially more complicated as more events are created. This solution allows there to be only one event manager, which does not know or care about the subtypes of the events, whereas the objects themselves “decode” the event by casting it back downwards to its specific, content-ful type. 
