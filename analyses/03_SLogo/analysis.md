#Analysis

##Project Journal
###Time Spent
When this project first started, I spent three or four hours with my group deciding how the application should be structured, and divvying up responsibilities. I then continued to think about the structure of the application on my own, as I was responsible for the client, turtle model/state, and view, so I spent 3-4 hours on top of that deciding exactly how each piece would communicate with the others. Then, I spent before the first deadline roughly two eight hour days developing the core structure of the application, about 25-30 classes. Then, for the second phase of the project, I thought about how to incorporate the demands into the existing design pattern for another couple of hours (most of the demands fit in well with our design; and the view was the only thing which I was really torn on). Our group met one final time, and I coded for seven hours straight with them. Overall, in sum, I spent roughly 24-25 hours on this project from start to finish. This work tended to be done in two types – planning type, where I silently contemplated how I wanted the design to look and thought exactly what types and calls the structures would need to be able to make, and burst type, where I would work for several to many hours in a row implementing all of my ideas (this was usually easy because by this time my ideas would be fully formed). For the first deadline, this proved to be a slight problem, as all four of our group members submitted substantial portions of the project into the master branch at the very end (Saturday night near midnight). However, by the end all sections were working, as far as I’m aware, and the code merged well, due to its highly modular design.
One other side effect of spending so much time planning without being at a computer is that the code rarely needed to be refactored or debugged. Refactoring is an important part of developing as code needs to be able to accommodate different features that the developers never intended, but if the developer uses patterns logically, and strongly decouples their features and structures, then refactoring can be radically cut down upon. 
###Group Responsibilities
Our group met two or three times as a whole to discuss core structure, and other than that, the separate parts largely kept to themselves for the remainder of the project. Our division was, Matt, Collin, and Randy all worked on the parser/interpreter, and I developed the client, turtle model/state structure, and the view hierarchy, along with the core application. Because of this, the other three group members could code largely amongst themselves and discuss their own problems, and all they had to do in terms of interaction with my code was to take in the interface cast of my client that they could send commands/requests to, and I would call the function in the client that started the parser. Our design was designed to completely decouple the interpreter subapplication from the turtle model/state and the view, because they are fundamentally separate concepts. I frankly am not completely sure how they split up work on the parser, but I believe it was largely separated after the basic structure by type of command (math command vs structural commands vs turtle queries, turtle commands, etc.). 
###Commits
My commit structure (and git usage as a whole for this project) was actually quite regular. I developed on a branch of master called core_app, and my structure here, while self-contained, was pretty good given it was over a two-day stretch. First, I committed most of the interfaces that I would need to use for my different sections to communicate with each other. After I wrote these, I started fleshing out the classes that would implement them, and committed most of the core client/model structure. Then, I started fleshing out the view interfaces, and restructured it to more robustly handle a large number of features/substructures. I then committed this. Finally, I got most of the commands working to interact between the turtle and the view, and committed these, along with the actual implementation for turtle state functions. Once all of these features were done, I asked my group to perform a merge with the master branch, as it was so large (25-30 classes) that I felt it would be best for someone to evaluate it.
For the second phase, I switched my development mostly onto a branch called front_end_extensions, given my role in the second phase of the project. Here, I started with a refactoring of my client and later of my view that would support commands for multiple turtles. Once I got that working and committed it (in two parts), I realized that I needed to help out with a little bit of debugging on the core commands of the interpreter, so I switched mostly to the master branch and starting running verifications and bug fixes so I knew that all of the draw commands would work. Then, I implemented an on-click for the turtle that would allow it to be set to active when clicked (if multiple turtles are active). The active system in back-end vs. view is still nascent and in my opinion relatively poorly linked, but it would pass most standard use cases, and provided much-needed visceral feedback to the largely threadbare, spartan design of the program. Finally, I fixed a couple of small bugs and committed.
###Conclusion
This project was, in broad strokes, a design success but in part an implementation failure. Most of the code looks very good, it is easy to append to, and developing new features was relatively easy. However, our group did not communicate enough, especially on the second phase of the project. In addition, I took on a very large portion of the work, which I enjoyed doing, especially because I felt like the design I built was very robust and ideal for the needs of this application. However, my front-end work was fairly well structured code-wise but frankly does not look very good; I do not have the instincts of a graphic designer. In addition, due to the large amount of responsibilities I had and the difficulty with which the parser attempted to evaluate command blocks, I was unable to spend time in the second phase developing a factory for the turtle’s drawcommands, and reflecting the classes displayed in the application section of the view. These are, with regards to the code that I wrote, the weakest parts of the application, and the only parts that I truly feel like are weak in design. 
As stated before, most of the code that I wrote worked without refactoring or debugging, because of the amount of time I spent thinking intimately about its structure and interactions. However, my view code took a fair amount of debugging (a couple hours), mainly because I am not familiar with the coordinate system that javafx employs. Were I to become a developer who used javafx extensively, I would want to familiarize myself more fully with these functions, and get closer to writing code that does not need to be debugged (as my coding on the backend has largely progressed to). 
Lastly, I would quickly add that in the future I plan to spend more time actually talking to my teammates about the code that they write, to make sure they are on track for deadlines and can easily integrate with the code that I write.

##Design Review
###Coding Conventions
In terms of overall readability and ease of use, our program is fairly strong. We made extensive use of packages, and sought to group like commands into their own packages, isolating the large number of command classes that we had to create and leaving most of the actual meat of the application in other packages that are easy to traverse. The core structure of the application, where the client interfaces between the parser, the view, and the turtle, along with any other subapplications that may become necessary (such as a defined command library) was in my opinion very strong and clearly written, facilitated by extensive use of interfaces which simply define the project in terms of the functions that different parts possess. The command pattern was used extensively, which to an unfamiliar user would almost certainly be confusing, but to a user familiar with the pattern would make the separate parts of the program easy to understand (each command is named exactly what it does, possesses the same core functions, and is passed to the proper channel through a function in the interface it goes into which simply accepts commands). 
In terms of naming conventions, the project is slightly less strong. We have several different types of commands, some of which are prefaced with “command,” some of which possess “command” as a suffix, and some of which are not affixed with “command” at all. Our member variables and function naming is better, mostly because we actually use very few variables, and because our functions tend to be implementations of interfaces which are often extensively shared.
###Dependencies
Our program possesses few dependencies that a user or developer would have to be aware of. The application instantiates its subapplications, which create command objects which are not dependent on anything other than parameters passed into them. These are passed through the client, which already exists, to the turtle model, by way of a multi-object holder, which handles instantiation and active handling of objects, and this holder is again already extant (having been built in the constructor of the client, along with the parser and the view). The commands then hit the turtle, which the object-holder has already instantiated and is ready to go out of the box, and gets executed and then saved for later, for its draw component. There previously was a circular dependency issue with the turtle, where it would attempt to draw itself in its constructor but could not reference itself in the object holder because it had not been instantiated yet, but this was simply resolved by moving the drawing of the turtle outside of the constructor. Because only the turtle manager creates turtles, and the turtle manager can simply draw the turtle right after construction in its own create turtle method, this is effectively the same as drawing the turtle at constructor time, and eliminates the dependency. The view constructs its turtles for drawing when a command is sent to it, and again can only be called by the turtle, which, since it is called through the turtle, predicates the turtle already exists, so there are no conflicts there. In summary, most of our dependencies are mitigated by strictly controlling access to separate components of the application.
###Code Review
I will look at two classes here that I did not write, the TreeCommandFactory, and the ParserCommandFactory. These two classes, while possessing very similar names, actually possess very different functions. The former is in charge essentially of taking every undifferentiated, untyped command, and attempting to figure out what it is and what to do with it. This is done apparently by means of a huge switch case statement, which matches string literals to the given token. Sometimes these correspond to a creation of a command object. Sometimes, for structural commands like “for” or “if” (but not Boolean commands like “and”), no actual command object is created, but code is run to simulate the actual command structure, which facilitates the creation of other command objects. Once all of these command objects are created, they are simply run one by one.
What is most confusing about this class is that it seems to be the control structure for the entire parser, running through a series of gigantic switch cases that determine which command object to create, but also maintaining a variety of different types of command (holding, for example, a value as a member variable that corresponds to the results of a math command being executed. The constructor of this object takes the command tree, and then it in turn makes every command at once. In addition, the switches are all done by comparison to hard-coded string literals. This code is strong in that it is intuitive and the structure that that it uses to parse a series of tokens is easy to understand, but does too many things and is difficult to debug. In addition, this design, because of how many things it does at once, is not very modular and does not meet possible demands that the parser may need to meet in the future (or in this case the present). For example, this structure has no way to create one command, pass it to the turtle, and then later ask the turtle what the results were. Further, it is hard to isolate in this class where the behavior that would do that occurs, so it is difficult to refactor.
The latter class, while still possessing a few problems, is a much stronger example of object-oriented design. The class does exactly what it says it does; that is, it creates a command to send to the turtle. All it does is take the same function, with either a Boolean argument, one double, or two doubles, and it always returns a command object, so the user does not have to worry about its actual class or subtype. Perhaps it could be called something other than parsercommand, as that would seem to imply something internal to the parser as opposed to a command that gets sent elsewhere, but that is a minor concern. In addition, string literals are still hardcoded into the factory, but for simple type checks this is relatively minor (I would probably move these to a properties file, but they are functional here). 
###Design 
This project was built on the core principle of complete and total decoupling of components. The SLOGO application, on a fundamental level, consists of disparate elements that may happen to interact with each other in the way the application is currently built, but by no means necessarily interact with each other by nature of their properties (it is easy to imagine, for example, a parser which instead of sending commands to a turtle model, posts them to an HTTP server which then updates a database, or a turtle that takes commands from a different parsing language). To this end, large sections of the work that the separate applications do must be mediated by go-betweens, and much of the work itself must be parameterized, down to the functions that are called. Further, the client that interfaces between the separate parts should know as little about the internal structure of the subapplications as possible, because there is nothing intrinsic about the client that should necessitate its coupling intimately with any subapplication. Because of this, the command and factory patterns were absolutely vital in the construction of our design. With that design philosophy prelude set, the core design of the application is as follows:
The core client does little work itself, instead interfacing between the views, the parser, and the turtle manager (which itself controls the actual turtles). Nothing actually happens in the application until text is entered into the code text area and the evaluate button is pressed. At this point, the text is sent from the view back down to the parser by way of the parser-client interface, which the parser and view have access to in order to communicate with the parser. This text is then passed into the parser, which tokenizes it and assembles a long list of tokens. Then, the TreeCommandFactory takes this list of tokens, analyzes them one by one, and figures out what they are and what should be done with them. At this point, there is a slight discrepancy. It was intended in our design for the parser to pass commands to the turtle by way of the client as it deciphered them, so that the state of the turtle could be instantly updated, and the turtle could be queried for state information. However, in the way that the design is currently implemented, the parser simply returns all of the commands to the client at the end of its command evaluation. At any rate, at some point the client gets commands, gets told which turtles are active from the turtle manager, and then sends commands to these turtles. The turtles then receive the commands, and as they receive them, execute their set commands, which change the internal state of the turtle. The command is then saved into a queue, where its second half will be executed later for drawing. Then, the turtle waits. Every frame, the application updates, and part of that update consists of telling each turtle to update. At this point, the turtle checks to see if it is doing anything and if there are any commands in its queue, and if it is able, pulls a command out of the queue and executes it. This then sends a draw command to the view, which starts updating the turtle. The other half of the application update is telling the view to update itself, and when its drawn turtle is not where a command has told it to be, it updates the drawn turtle (consisting of an imageview, coordinates, heading, and new coordinates and heading data). When it has reached its destination, it tells the client (by way of the drawclient interface, which is how the view interacts with the turtle) that it is done drawing some turtle. The client then relays that information to that turtle, which now knows it is no longer drawing, and can execute its next command. 
###Adding New Pieces
Adding a new piece can either be relatively easy or very difficult, depending on the section being modified. To add a new front-end component, one simply creates the class for the component, fills it with the proper coordinate and spatial information, and creates it in the applicationview’s create section. I intended to reflect this process, pulling the names of the classes to instantiate out of a properties file, but I ran out of time and was unable to do so. However, the process is still mostly closed for existing classes. 
Adding a new parser command is relatively easy, but certain concerns may be raised. To add a new command, the class containing the command is built, and the command is added to the factory. In addition, if it a command passed to the turtle, it must be added to a turtle command factory, and depending on what it does, one must decide whether it requires modification of the drawable interface. However, there are very few commands left that one could request the turtle to do that are not a linear combination of existing commands. This, still, is probably the weakest part of the design in terms of closure. Because the commands take in an object of type drawable interface, the new functionality cannot simply be added to a new interface, because we cannot rely on an object to implement that interface. We could create an abstract base class that implements multiple interfaces, but then at that point there is no real reason to have the functionality in separate interfaces at all, and splitting them up logically is difficult and would also violate closure. However, this is, relatively speaking, unavoidable. When you want to add a command which tells the turtle to do a new thing, you also have to implement the ability for the turtle to do that thing, unless you are comfortable with simply sending the command and not caring whether the turtle actually does anything with it or not. Therefore, you must implement functionality on both the parser command side and on the side of the turtle. (However, in the general case where the commands are not directly instructing the turtle to do a new thing, creation of a new command is still easy). 
Implementing one of the unimplemented features ranges from trivially easy to somewhat difficult for our design. For the sake of interest, I will pick something relatively difficult. Implementing on the front end components to, for example, pick brush color or background color, is quite easy. However, there is no current interface that mediates between the drawing section and the application section of the view. This would be relatively easy – simply have the client implement an interface that mediates interaction between the two pieces, and then this interface could pass things such as brush color, width, etc. This requires the creation of a new interface, and an implementation of its methods, in addition to the class describing the actual spatial javafx code, but all in all is still relatively easy (and, once the interface is implemented, because it is known to only be implemented on the client for now, it is easy to modify for additional functionality). If that is still too open, the interface could possibly take commands and pass them from one side to the other, although that would require some thought on what exactly the command is being sent to and how different objects on the different sides are parametrically differentiated (how, for example, does the command know to set the brush width or color as opposed to the background color, without adding a new function to the drawinterface every time a new function is created, which is simply moving the problem around?)
We could also try to implement something even harder, such as highlighting a command as the turtle animates it. Because the animations for the turtle are well-differentiated and happen sequentially, this would actually not be that difficult. When the parser parses all of its commands, and the turtle starts drawing, it could keep a count of what draw command it is on, and increment every time a new command is sent. This integer count could then be passed into the client on the view’s update function, which could in turn pass it into the parser. The parser could take this integer, figure out which of the commands it previously referred to, and pass to the client an integer value corresponding to a location on the text string where the command starts, and a value where the command ends. The client could then pass these two values to the application view, where a highlight is performed in the text area starting at the first value and ending at the second value. The biggest difficulties here lie in the parser figuring out what integer corresponds to what command, and then subsequently figuring out where the command occurred in the text string it was first given. However, as a client/model engineer who did not work on the parser, I would leave that problem to the designers of the parser.
#Alternate Designs
I will not go too much into detail here, for the sake of length, but because of the needs we saw in this program, few alternative designs were considered for the core structure of the application. However, in speaking with people who had previously taken this class and with classmates who were working on their own groups, I did hear some other designs, and will compare our design with one in particular: the paradigm of the observable list.
The observable list structure of the SLOGO application is relatively similar to the design that we used, but instead of passing commands to the turtle, which then updated its state, the parser instead modifies some sort of small database-like structure that contains the state data – coordinates, heading, penUp, etc. The view then looks at this list, and detects changes. Whenever it detects a change, it starts to move its representation to match what is currently observed. 
This structure is useful in that it is a very intuitive way to think about the turtle and its relation to the view. Instead of having to send a bunch of functions around, you can simply modify one central location and the rest of the application will look at that location and act accordingly. However, it possesses one serious drawback that is substantial enough, in my opinion, to not be used for the project: the strong coupling between turtle state and draw state. While the relationship is intuitive, it falls apart on closer inspection and makes implementing certain things very difficult. For example, if the parser receives 20 commands at once, parses them all, and in a tiny period of time, modifies the central location several times, the view is not going to be able to execute those commands in order. That doesn’t matter if the turtle moves instantaneously, but if the turtle needs to slowly move forward fifty, and then backward fifty, two updates to the state with the observable system will result in the turtle possibly not moving at all. Because the turtle cannot execute several animations at once, there must therefore be some sort of management structure to control when and how the turtle does its actual drawing.
##Masterpiece
The code I am submitting for my masterpiece is my client, which handles the interactions between all the different parts of the application. The reason that I think this code is so well done is that it implements several interfaces that reflect singular, atomic purposes that the client fulfills, and then passes itself into other objects as that interface, to limit the functionality of the client that is accessible from the other object. This client manages interactions between the view, which asks it for information about the turtle, for commands, for information from another part of the view, and tells it to talk to the turtle; the turtle manager, which determines which turtles are active and handles turtle instantiation and id accessing; the turtle itself, which sends commands to the view and receives commands from the parser; which sends commands to the turtle and receives text from the view. 
There are other parts of my design which I feel are also well done, but are deficient in some part that would have been included in the masterpiece (such as the view system, which is as a whole very well done but does not contain reflected components on the applicationview side, which I view as somewhat deficient, or the turtle-view interactions system, which is very good but would expose the drawable interface which consists of many methods right now, underlying the fact that the application needs to be able to rely on the turtle to do many different things, but it is unclear where to implement new things that the turtle needs to be able to do without violating closure (if the commands are moved to different interfaces that a base class implements, then creation of new features still requires the base class to implement new interfaces or define its own new functions). However, the client code is, mostly speaking, free of any design questions such as these. Therefore, I wholeheartedly endorse the client code as the best example of strongly decoupled, dependency-inversed code I have written for this project.
